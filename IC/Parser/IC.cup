package IC.Parser;

import IC.AST.*;
import IC.*;
import java_cup.runtime.*;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.List;

parser code  {:
	/** Causes the parser to print every token it reads.
	 * This is useful for debugging.
	 */
	public boolean printTokens = true;
	
	private Lexer lexer;

	public parser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
	
	// we can use it to get the line number of current token
	public int getLine() {
		return lexer.getLineNumber();
	}
	
	// we can use it to get the column number of current token
	public int getColumn() {
		return lexer.getColumnNumber();
	}
	
	public void syntax_error(Symbol s) {
		Token tok = (Token) s;
		System.out.println("Line " + tok.getLine()+": Syntax error; unexpected " + tok);
	}
:}

// This is just for debugging
scan with {:
	Token t = lexer.next_token();
	if (printTokens)
		System.out.println(t.getLine() + ":" + t.getTagString() + ",\t" + t.getValue());
	return t; 
:};

////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

/////			Terminals			/////

// general
terminal Integer 	NUM;
terminal String  	ID;
terminal String 	CLASS_ID;
terminal String 	STR; // an actual string like "Nice"

// operators
terminal PLUS, MINUS, MULTIPLY, DIVIDE, NEGATION, REMAINDER, BIG, BIGEQ;
terminal SMALL, SMALLEQ, EQ, EQCOMP, AND, OR, DOT, NOTEQCOMP;

// punctuation
terminal LP, RP, LB, RB, LCBR, RCBR, SEMI, COMMA;

// keywords
terminal CLASS, EXTENDS, STATIC, VOID, BOOLEAN, RETURN, IF, ELSE, WHILE;
terminal BREAK, CONTINUE, THIS, NEW, LENGTH, TRUE, FALSE, NULL;
terminal INT; // the keyword int
terminal STRING; // the keyword string


/////			Non-Terminals			/////

nonterminal Program program;
nonterminal List<ICClass> class_list;
nonterminal ICClass classDecl;
nonterminal String optionalExtends;
nonterminal FieldsOrMethods fieldsnmethods;
nonterminal List<Field> fields;
nonterminal List<String> optionalFields;
nonterminal Method method;
nonterminal Type type;
nonterminal Type typenvoid;
nonterminal Type virtualvoid;
nonterminal List<Formal> formalsList;
nonterminal List<Formal> formals;

// statements related
nonterminal List<Statement> stmt_list;
nonterminal Statement stmt;
nonterminal Expression expr;
nonterminal Location location;
nonterminal CallStatement callStatement;
nonterminal Call call;
nonterminal StaticCall staticCall;
nonterminal VirtualCall virtualCall;
nonterminal List<Expression> expr_args;
nonterminal List<Expression> expr_comma;
nonterminal Expression optionalReturnValue;
nonterminal Statement optionalElse;

//////////////////////////
// Precedence declarations

precedence left ELSE;

//////////////
// The grammar

program ::= class_list:cl
     {: RESULT = new Program(cl); :}
;

class_list ::= class_list:cl classDecl:c
      {: cl.add(c); RESULT = cl; :}
      | // epsilon
      {: RESULT = new LinkedList<ICClass>(); :}
;

classDecl ::= CLASS CLASS_ID:c optionalExtends:ext LCBR fieldsnmethods:x RCBR
		{:
			if(ext != null)
				RESULT = new ICClass(cleft, c, ext, x.getFields(), x.getMethods());
			else
				RESULT = new ICClass(cleft, c, x.getFields(), x.getMethods());
		:}
;

optionalExtends ::= EXTENDS CLASS_ID:c
				{: RESULT = c; :}
				| // epsilon
				{: RESULT = null; :}
;

fieldsnmethods ::= fieldsnmethods:lst fields:c
					{: lst.add(c); RESULT = lst; :}
					| fieldsnmethods:lst method:c
					{: lst.add(c); RESULT = lst; :}
					| // epsilon
					{: RESULT = new FieldsOrMethods(); :}
;

fields ::= type:t ID:i optionalFields:f SEMI
		{:
			f.add(0,i);
			RESULT = new LinkedList<Field>();
			for (String s : f)
				RESULT.add(new Field(t,s));;
		:}
;

optionalFields ::= optionalFields:f COMMA ID:i
				{: f.add(i); RESULT = f; :}
				| // epsilon
				{: RESULT = new LinkedList<String>(); :}
;

method ::= STATIC typenvoid:t ID:i LP formalsList:f RP LCBR stmt_list:s RCBR
			{: RESULT = new StaticMethod(t,i,f,s); :}
			| type:t ID:i LP formalsList:f RP LCBR stmt_list:s RCBR
			{: RESULT = new VirtualMethod(t,i,f,s); :}
			| virtualvoid:t ID:i LP formalsList:f RP LCBR stmt_list:s RCBR
			{: RESULT = new VirtualMethod(t,i,f,s); :}
;

virtualvoid ::= VOID:v
			{: RESULT = new PrimitiveType(getLine(),DataTypes.VOID); :} // can use vleft ...
;

typenvoid ::= VOID:v {: RESULT = new PrimitiveType(getLine(),DataTypes.VOID); :}
			| type:t {: RESULT = t; :}
;

type ::= INT:n
		{: RESULT = new PrimitiveType(getLine(),DataTypes.INT); :} // can use nleft instead of getLine()
		| BOOLEAN:b
		{: RESULT = new PrimitiveType(getLine(),DataTypes.BOOLEAN); :} // can use bleft instead of getLine()
		| STRING:s
		{: RESULT = new PrimitiveType(getLine(),DataTypes.STRING); :} // can use sleft instead of getLine()
		| CLASS_ID:c
		{: RESULT = new UserType(getLine(),c); :} // can use cleft instead of getLine()
		| type:t LB RB
		{: t.incrementDimension(); RESULT = t; :}
;

formalsList ::= formals:f
			{: RESULT = f; :}
			| // epsilon
			{: RESULT = new LinkedList<Formal>(); :}
;

formals ::= type:t ID:i
			{: RESULT = new LinkedList<Formal>(); RESULT.add(new Formal(t,i)); :}
			| formals:f COMMA type:t ID:i
			{: f.add(new Formal(t,i)); RESULT = f; :}
;

// statements related
stmt_list ::= stmt_list:lst stmt:s
		{: lst.add(s); RESULT = lst; :}
		| // epsilon
		{: RESULT = new LinkedList<Statement>(); :}
;

stmt ::= type:t ID:i SEMI
		{: RESULT = new LocalVariable(t,i); :}
		| type:t ID:i EQ expr:e SEMI
		{: RESULT = new LocalVariable(t,i,e); :}
		| callStatement:c SEMI
		{: RESULT = c ; :}
		| RETURN optionalReturnValue:or SEMI
		{: RESULT = new Return(getLine(),or); :}
		| IF LP expr:cond RP stmt:s optionalElse:e
		{: RESULT = new If(cond,s,e); :}
		| WHILE LP expr:cond RP stmt:s
		{: RESULT = new While(cond,s) ; :}
		| BREAK SEMI
		{: RESULT = new Break(getLine()) ; :}
		| CONTINUE SEMI
		{: RESULT = new Continue(getLine()); :}
		| LCBR stmt_list:sl RCBR
		{: RESULT = new StatementsBlock(getLine(),sl); :}
;

optionalElse ::= ELSE stmt:s
		{: RESULT = s ; :}
		| // epsilon
		{: RESULT = null ; :}
;

optionalReturnValue ::= expr:e
		{: RESULT = e ; :}
		| // epsilon
		{: RESULT = null ; :}
;

expr ::= location:l {: RESULT = l; :}
		| call:c {: RESULT = c; :}
		| THIS:t {: RESULT = new This(tleft); :}
		| NEW CLASS_ID:c LP RP {: RESULT = new NewClass(cleft,c); :}
		| NEW type:t LB expr:e RB {: RESULT = new NewArray(t,e); :}
		| expr:e DOT LENGTH {: RESULT = new Length(e); :}
;

location ::= ID:i {: RESULT = new VariableLocation(ileft,i); :}
			| expr:e DOT ID:i
			{: RESULT = new VariableLocation(ileft,e,i); :}
			| expr:e1 LB expr:e2 RB
			{: RESULT = new ArrayLocation(e1,e2); :}
;

callStatement ::= call:c {: RESULT = new CallStatement(c); :}
;

call ::= staticCall:s {: RESULT = s; :}
		| virtualCall:v {: RESULT = v; :}
;

staticCall ::= CLASS_ID:c DOT ID:i LP expr_args:args RP
			{: RESULT = new StaticCall(ileft,c,i,args); :}
;

virtualCall ::= expr:e DOT ID:i LP expr_args:args RP
			{: RESULT = new VirtualCall(ileft,e,i,args); :}
			| ID:i LP expr_args:args RP
			{: RESULT = new VirtualCall(ileft,i,args); :}
;

expr_args ::= expr:e expr_comma:lst
			{: lst.add(0, e); RESULT = lst; :}
			| // epsilon
			{: RESULT = new LinkedList<Expression>(); :}
;

expr_comma ::= expr_comma:lst COMMA expr:e
			{: lst.add(e); RESULT = lst; :}
			| // epsilon
			{: RESULT = new LinkedList<Expression>(); :}
;
