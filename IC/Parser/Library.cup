package IC.Parser;

import IC.AST.*;
import IC.*;
import java_cup.runtime.*;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.List;
import java.util.Collections;

parser code  {:
	
	private Lexer lexer;
	private boolean encounteredError = false;

	public LibParser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
	
	public boolean parserFailed() {
		return encounteredError;
	}
	
	// we can use it to get the line number of current token
	public int getLine() {
		return lexer.getLineNumber();
	}
	
	// we can use it to get the column number of current token
	public int getColumn() {
		return lexer.getColumnNumber();
	}
	
	public static String parseString(String str) {
		StringBuffer sb = new StringBuffer();
		boolean writeChar = false;
		int n = str.length();
		for (int j = 1; j <= n - 2; j++) {
			char c = str.charAt(j);
			if (writeChar) {
				if (c == 'n')
					sb.append("\n");
				else if (c == 't')
					sb.append("\t");
				else
					sb.append(c);
				
				writeChar = false;
			} else if (c != '\\') {
				sb.append(c);
			} else { // else str.charAt(j) == '\\'
				writeChar = true;
			}
		}
		return sb.toString();
	}
	
	public void print_syntax_error(Token tok, List<String> sortedlst) {
		StringBuffer sb = new StringBuffer();
		
		if (!sortedlst.isEmpty()) {
			boolean firstStr = true;
			for (String str : sortedlst) {
				if (firstStr) {
					firstStr = false;
					sb.append("'" + str + "'");
				} else {
					sb.append(" or '" + str + "'");
				}
			}
		}
		String errMsg = "expected " + sb.toString() + ", but found '" + tok.getValue() + "'";
		System.err.println(tok.getLine() + ":" + tok.getColumn() + " : " + errMsg);
	}
	
	public void unrecovered_syntax_error(Symbol s) throws SyntaxError {
		Token tok = (Token) s;
		throw new SyntaxError("",tok.getLine(),tok.getColumn());
	}
	
	public void syntax_error(Symbol s) {
		List<Integer> expectedTags = expected_token_ids();
		
		if (expectedTags.isEmpty())
			expectedTags = expected_token_ids();
			
		if (expectedTags.isEmpty())
			expectedTags = expected_token_ids();
		
		List<String> sortedlst = new LinkedList<String>();
		for (Integer n : expectedTags) {
			String str = Token.convertTag(sym.terminalNames[n]);
			if(str != null)
				sortedlst.add(str);
		}
		
		// sort sortedlst lexicographically
		Collections.sort(sortedlst);
		
		print_syntax_error((Token) s, sortedlst);
		encounteredError = true;
	}
	
:}

////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

/////			Terminals			/////

// general
terminal String 	NUM;
terminal String  	ID;
terminal String 	CLASS_ID;
terminal String 	STR; // an actual string like "Nice"

// operators
terminal PLUS, MINUS, MULTIPLY, DIVIDE, NEGATION, REMAINDER, BIG, BIGEQ;
terminal SMALL, SMALLEQ, EQ, EQCOMP, AND, OR, DOT, NOTEQCOMP;

// punctuation
terminal LP, RP, LB, RB, LCBR, RCBR, SEMI, COMMA;

// keywords
terminal CLASS, EXTENDS, STATIC, VOID, BOOLEAN, RETURN, IF, ELSE, WHILE;
terminal BREAK, CONTINUE, THIS, NEW, LENGTH, TRUE, FALSE, NULL;
terminal INT; // the keyword int
terminal STRING; // the keyword string

// unreal terminals
terminal UMINUS, LNEG;

/////			Non-Terminals			/////

nonterminal ICClass libic;
nonterminal List<Method> libmethodList;
nonterminal LibraryMethod libmethod;
nonterminal Type type;
nonterminal Type typenvoid;
nonterminal List<Formal> formalsList; // list can be empty
nonterminal List<Formal> formals; // list can't be empty 

//////////////////////////
// Precedence declarations

//////////////
// The grammar

libic ::= CLASS CLASS_ID:c LCBR libmethodList:lst RCBR
		{: 
			if(!c.equals("Library")) {
				encounteredError = true;
				String errMsg = "expected 'Library', but found '" + c + "'";
				System.err.println(cleft + ":" + cright + " : " + errMsg);
			}
			RESULT = new ICClass(cleft, c, new LinkedList<Field>(), lst); 
		:}
		| error LCBR libmethodList:lst RCBR
;

libmethodList ::= libmethodList:lst libmethod:m
			{: lst.add(m); RESULT = lst; :}
			| // epsilon
			{: RESULT = new LinkedList<Method>(); :}
;

libmethod ::= STATIC typenvoid:t ID:method LP formalsList:f RP SEMI
			{: RESULT = new LibraryMethod(t,method,f); :}
			| error LP formalsList:f RP SEMI
;

typenvoid ::= VOID:v {: RESULT = new PrimitiveType(getLine(),DataTypes.VOID); :}
			| type:t {: RESULT = t; :}
;

type ::= INT:n
		{: RESULT = new PrimitiveType(getLine(),DataTypes.INT); :} // can use nleft instead of getLine()
		| BOOLEAN:b
		{: RESULT = new PrimitiveType(getLine(),DataTypes.BOOLEAN); :} // can use bleft instead of getLine()
		| STRING:s
		{: RESULT = new PrimitiveType(getLine(),DataTypes.STRING); :} // can use sleft instead of getLine()
		| CLASS_ID:c
		{: RESULT = new UserType(getLine(),c); :} // can use cleft instead of getLine()
		| type:t LB RB
		{: t.incrementDimension(); RESULT = t; :}
;

formalsList ::= formals:f
			{: RESULT = f; :}
			| // epsilon
			{: RESULT = new LinkedList<Formal>(); :}
;

formals ::= type:t ID:i
			{: RESULT = new LinkedList<Formal>(); RESULT.add(new Formal(t,i)); :}
			| formals:f COMMA type:t ID:i
			{: f.add(new Formal(t,i)); RESULT = f; :}
;

